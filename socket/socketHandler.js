// Generated by CoffeeScript 1.9.3
(function() {
  var SocketHandler, async, net, singleton;

  net = require('net');

  async = require('async');

  SocketHandler = (function() {
    function SocketHandler(port) {
      this.port = port;
      this.port = 8484;
      this.clients = [];
      this.listeners = {};
      this.key = 0;
    }

    SocketHandler.prototype.connect = function() {
      net.createServer((function(_this) {
        return function(sock) {
          var msg;
          msg = '';
          log.info("CONNECTED " + sock.remoteAddress + " " + sock.remotePort);
          sock.setNoDelay(true);
          sock.on('error', function(err) {
            log.warn('Socket ERROR');
            log.warn(err);
            log.warn(err.stack);
            delete sock.name;
            return delete sock.identifier;
          });
          sock.on('message', function(data) {
            var protocol;
            protocol = data;
            switch (protocol.messageType) {
              case 'Gateway':
                return _this.gatewayHandler(protocol, sock);
              case 'AsyncUpnpMessage':
                return _this.asyncUpnpMessageHandler(protocol, sock);
              case 'requestDeviceControl':
                _this.listeners[protocol.key].callback(null, protocol.data);
                return delete _this.listeners[protocol.key];
              default:
                return log.warn("Another message type : " + protocol.messageType);
            }
          });
          sock.on('data', function(data) {
            var i;
            msg += data.toString('utf8');
            i = msg.indexOf('\0');
            if (i !== -1) {
              sock.emit('message', JSON.parse(msg.substring(0, i)));
              return msg = msg.substring(i + 1);
            }
          });
          return sock.on('close', function(data) {
            log.info("CLOSED " + sock.remoteAddress + " " + sock.remotePort);
            log.info(sock.name);
            log.info(sock.identifier);
            log.info(_this.clients.indexOf(sock));
            return _this.clients.splice(_this.clients.indexOf(sock), 1);
          });
        };
      })(this)).listen(this.port);
      return log.info('TCP server listening on port ' + this.port);
    };

    SocketHandler.prototype.getSocketKey = function() {
      return ++this.key;
    };

    SocketHandler.prototype.getClientIndex = function(name, identifier) {
      var idx, item, j, len, ref;
      ref = this.clients;
      for (idx = j = 0, len = ref.length; j < len; idx = ++j) {
        item = ref[idx];
        if (item.identifier === identifier && item.name === name) {
          return idx;
        }
      }
      return -1;
    };

    SocketHandler.prototype.gatewayHandler = function(protocol, sock) {
      var selector;
      log.info('gatewayHandler');
      sock.name = protocol.name;
      sock.identifier = protocol.identifier;
      this.clients.push(sock);
      selector = {
        name: protocol.name,
        identifier: protocol.identifier
      };
      return async.waterfall([
        function(callback) {
          return DB.gateway.find(selector, function(err, gateways) {
            return callback(err, gateways);
          });
        }, function(gateways, callback) {
          protocol.online = true;
          if (gateways.length === 0) {
            return DB.gateway.create(protocol, function(err, gateway) {
              return callback(err, gateway);
            });
          } else {
            gateways[0].name = protocol.name;
            gateways[0].identifier = protocol.identifier;
            gateways[0].online = true;
            return gateways[0].save(function(err, gateway) {
              return callback(err, gateway);
            });
          }
        }
      ], function(err, gateway) {
        if (err) {
          log.warn(err);
          return sock.write(JSON.stringify({
            error: 'gatewayHandler error'
          }) + '\n');
        } else {
          return sock.gateway = gateway;
        }
      });
    };

    SocketHandler.prototype.asyncUpnpMessageHandler = function(protocol, sock) {
      var selector, uuid;
      selector = {
        name: sock.name,
        identifier: sock.identifier
      };
      uuid = protocol.type !== "DeviceEvent" ? protocol.data.identity.udn.identifierString : protocol.data.udn;
      console.log(uuid);
      return async.waterfall([
        function(callback) {
          return DB.gateway.find(selector).run(function(err, gateways) {
            return callback(err, gateways);
          });
        }, function(gateways, callback) {
          var deviceQuery;
          if (gateways.length !== 1) {
            return callback("gateway length is " + gateways.length + ". I want gateway length is 1");
          } else {
            deviceQuery = {
              gateway: gateways[0].id,
              uuid: uuid
            };
            return DB.device.find(deviceQuery).run(function(err, devices) {
              return callback(err, devices, gateways[0]);
            });
          }
        }, function(devices, gateway, callback) {
          var device;
          if (devices.length === 0) {
            device = {
              uuid: uuid,
              gateway: gateway.id
            };
            return DB.device.create(device, function(err, newDevice) {
              return callback(err, newDevice, gateway);
            });
          } else if (devices.length !== 1) {
            return callback("device length not 1");
          } else {
            return callback(null, devices[0], gateway);
          }
        }
      ], function(err, result) {
        if (err) {
          return log.warn(err);
        }
      });
    };

    SocketHandler.prototype.requestSetAlarm = function(name, identifier, uuid, data, callback) {
      var index;
      index = this.getClientIndex(name, identifier);
      if (index < 0) {
        return callback(500);
      }
      return this.write(name, identifier, {
        responseType: 'requestSetAlarm',
        uuid: uuid,
        data: data
      });
    };

    SocketHandler.prototype.requestDeviceControl = function(name, identifier, uuid, data, callback) {
      var index, key;
      index = this.getClientIndex(name, identifier);
      if (index < 0) {
        return callback(500);
      }
      key = this.getSocketKey();
      this.listeners[key] = {
        key: key,
        name: name,
        identifier: identifier,
        messageType: 'requestDeviceControl',
        uuid: uuid,
        query: query,
        data: data,
        callback: callback
      };
      return this.write(name, identifier, {
        key: key,
        responseType: 'requestDeviceControl',
        uuid: uuid,
        query: query,
        data: data
      });
    };

    SocketHandler.prototype.write = function(name, identifier, object) {
      var selectedClients;
      selectedClients = this.clients.filter(function(item) {
        if (item.identifier === identifier && item.name === name) {
          return item;
        }
      });
      return selectedClients[0].write(JSON.stringify(object) + '\n');
    };

    return SocketHandler;

  })();

  singleton = {};

  singleton.instance = null;

  singleton.getInstance = function() {
    if (this.instance === null) {
      this.instance = new SocketHandler();
    }
    return this.instance;
  };

  module.exports = singleton.getInstance();

}).call(this);

//# sourceMappingURL=socketHandler.js.map
